import re

import json
from tools import search_emails, read_email
from typing import List
from dataclasses import asdict


def parse_from_response(response: str, parse_string: str) -> str | None:
    """Parse a data from a response."""

    # re.DOTALL is used to all \n inside the think tags
    # ? matches lazily meaning we pick the content inside the first <think> </think>

    data = re.search(rf'<{parse_string}>(.*?)</{parse_string}>', response, re.DOTALL)
    if data:
        return data.group(1)
    return None



SYSTEM_PROMPT = """
You're an helpful email agent. You need to answer questions and doubts with the help tools given to you. 
* Always answer in concise manner.
* You can use the tools as many times as you want. 
* Always double check your answers before giving the final answer even if requires additional tool calls. 
* You can only make a single tool call at a time but can also make multiple tools calls one after the another. 
* Your single turn is over after you answer tags. 
* Make at least 1 tool calls before giving your final answer and atmost of 2 tool calls.

You have access to the following tools:
- search_emails(keywords: List[str]) -> List[str]: Searches the email database based on keywords, inbox, sender, recipient, and date range.
- read_email(email_id: str): Retrieves a single email by its message_id from the database.


# Tool Usage Tips: 
* The list of keywords need to be smart. The search tool will look for the all the keywords in the list and return the emails that all the kewyords. 
* Keep the list of keywords simple and make multiple tool calls instead of nesting all the keywords in the a single tool call. 
* Hint: Stick to a single word or things like "jet ski" instead of clubbing everything

* For Example, you can call the tool like this
<tool>
{
    "name": "search_emails",
    "args": {
        "keywords": ["Meeting on Friday"]
    }
}
</tool>


* In each turn, you should respond in the following format:

<think>
[your thoughts here]
</think>
<tool>
JSON with the following fields:
- name: The name of the tool to call
- args: A dictionary of arguments to pass to the tool (must be valid JSON)
</tool>

When you are done, give your final answer in the following format:

<answer>
[your final answer here]
</answer>
"""


REWARD_MODEL_SYSTEM_PROMPT = """
You are given a question, the reference answer (labelled **Reference answer**), and an answer generated by an AI assistant (labelled **AI answer**).
Your task is to decide whether the AI answer is correct and should be accepted. You should accept the answer if it contains the relevant information from the reference answer. You should not accept the answer if it is missing information relevant to the question, or if it contradicts the reference answer.
Your reward can be 1 or 0. Nothing else
Give your reward value in <reward>your reward value goes here...</reward>
"""

async def call_tool(inbox: str, tool_call: dict) -> str:
    """Call a tool with the given tool call."""

    if tool_call['name'] == 'search_emails':
        return json.dumps([asdict(email) for email in search_emails(inbox, tool_call['args']['keywords'])])

    elif tool_call['name'] == 'read_email':
        return json.dumps(read_email(tool_call['args']['email_id']).model_dump())

    else:
        return f"Error: Tool {tool_call['name']} not found"